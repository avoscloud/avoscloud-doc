{% import "views/_helper.njk" as docs %}
{% import "views/_data.njk" as data %}
{% import "views/_sms.njk" as sms %}
{% import "views/_parts.html" as include %}
{% set middot = '·' %}
{% set link_to_blog_password_reset = '关于自定义邮件模板和验证链接，请参考《[自定义应用内用户重设密码和邮箱验证页面](https://blog.leancloud.cn/607/)》。' %}
{% set app_permission_link = "[控制台 > 存储 > 设置 > 用户账号](/dashboard/storage.html?appid={{appid}}#/storage/conf)" %}
{% set query_result_limit = "每次查询默认最多返回 100 条符合条件的结果，要更改这一数值，请参考 [限定结果返回数量](#限定返回数量)。" %}
{% set tutorial_restaurant = '[《教程 · 开发餐厅座位预订系统》](app-sample-restaurant.html)'%}

# 数据存储开发指南 &middot; {{platform_name}}

数据存储（{{productName}}）是 LeanCloud 提供的核心功能之一。下面我们用一个简单的示例来说明它的基本用法。

下面这段代码在创建了一个 `Todo` 类型的对象，并将它保存到云端：

{% block code_quick_save_a_todo %}{% endblock %}

如果你熟悉关系型数据库的话，需要注意 {{productName}} 的不同点。在 {{productName}} 里不需要事先建立表结构（schema），并且可以随时增加新的属性。通常这被称为无模式（schema-free）。例如，为上面的 Todo 类型新增一个表示地点的 `location` 属性，只需做如下变动：

  {% block code_quick_save_a_todo_with_location %}{% endblock %}

- 我们为各个平台或者语言开发的 SDK 在底层都是通过 HTTPS 协议调用统一的 [REST API](rest_api.html)，提供完整的接口对数据进行各类操作。

{{productName}} 在结构化数据存储方面，与 MySQL、Postgres、MongoDB 等数据库的区别在于：

1. 数据库是面向服务器端的，用户自己开发的服务器端程序以用户名和密码登录到数据库。用户需要在服务器端程序里自己实现应用层的权限管理并向客户端提供接口。{{productName}} 是面向客户端的存储服务，通过 ACL 机制在 API 层面提供了完整的权限管理功能。很多开发者都选择通过在客户端集成 {{productName}} SDK 来直接访问数据，而不再开发服务端的程序。
2. 与关系型数据库（MySQL、Postgres等）相比，{{productName}} 对多表查询（join）和事务等功能的支持较弱，所以在有些应用场景中会需要以有一定冗余的方式存储数据，以此换来的是良好的可扩展性，更有利于支撑起大流量的互联网应用。

下面我们逐一介绍 {{productName}} 支持的两类数据：

* 对象
* 文件

{% block section_sdk_setup %}
## SDK 安装

{% block text_and_link_to_install_doc %}
请阅读 [{{platform_name}} 安装指南](sdk_setup-{{segment_code}}.html)。
{% endblock %}

{% endblock %}

{% block text_web_security %}{% endblock %}

{{ include.debuglog(segment_code | lower, "##") }}

## 对象

`{{baseObjectName}}` 是 {{productName}} 对复杂对象的封装，每个 `{{baseObjectName}}` 包含若干属性值对，也称键值对（key-value）。属性的值是与 JSON 格式兼容的数据。通过 REST API 保存对象需要将对象的数据通过 JSON 来编码。这个数据是无模式化的（schema free），这意味着你不需要提前标注每个对象上有哪些 key，你只需要随意设置键值对就可以，云端会保存它。

{% block text_object_extra %}{% endblock %}

### 数据类型
`{{baseObjectName}}` 支持以下数据类型：

{% block code_data_type %}{% endblock %}

注意，时间类型在云端将会以 UTC 时间格式存储，但是客户端在读取之后会转化成本地时间。

{% block section_dataType_largeData %}
我们**不推荐**在 `{{baseObjectName}}` 中使用 `{{byteType}}` 来储存大块的二进制数据，比如图片或整个文件。**每个 `{{baseObjectName}}` 的大小都不应超过 128 KB**。如果需要储存更多的数据，建议使用 [`{{fileObjectName}}`](#文件)。
{% endblock %}

若想了解更多有关 LeanStorage 如何解析处理数据的信息，请查看专题文档《[数据与安全](./data_security.html)》。

### 构建对象
构建一个 `{{baseObjectName}}` 可以使用如下方式：

{% block code_create_todo_object %}{% endblock %}

每个 {{objectIdName}} 必须有一个 Class 类名称，这样云端才知道它的数据归属于哪张数据表。

{{ docs.alert(data.classNameConvention()) }}

### 保存对象
现在我们保存一个 `TodoFolder`，它可以包含多个 Todo，类似于给行程按文件夹的方式分组。我们并不需要提前去后台创建这个名为 **TodoFolder** 的 Class 类，而仅需要执行如下代码，云端就会自动创建这个类：

{% block code_save_todo_folder %}{% endblock %}

创建完成后，打开 [控制台 > 存储](/dashboard/data.html?appid={{appid}}#/)，点开 **TodoFolder** 类，就可以看到刚才添加的数据。除了 name、priority（优先级）之外，其他字段都是数据表的内置属性。

内置属性|类型|描述
---|---|---
`objectId`|{{ "str" if segment_code == "python" else "String"}}|该对象唯一的 Id 标识
`ACL`|{{ "leancloud.ACL" if segment_code == "python" else "ACL"}}|该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。
`createdAt`|{{dateType}}|该对象被创建的 UTC 时间
`updatedAt` |{{dateType}}|该对象最后一次被修改的时间

<dl>
  <dt>属性名</dt>
  <dd>也叫键或 key，必须是由字母、数字或下划线组成的字符串。<br/>自定义的属性名，{{ docs.alertInline("不能以双下划线 `__` 开头，也不能与以下系统保留字段和内置属性重名（不区分大小写）") }}。
  <div class="callout callout-danger monospace" style="margin-top:1em;color:#999;">{{ data.preservedWords() }}</div></dd>
  <dt>属性值</dt>
  <dd>可以是字符串、数字、布尔值、数组或字典。</dd>
</dl>

为提高代码的可读性和可维护性，建议使用驼峰式命名法（CamelCase）为类和属性来取名。类，采用大驼峰法，如 `CustomData`。属性，采用小驼峰法，如 `imageUrl`。

#### 使用 CQL 语法保存对象
{{productName}} 提供了类似 SQL 语法中的 Insert 方式保存一个对象，例如保存一个 TodoFolder 对象可以使用下面的代码：

{% block code_save_object_by_cql %}{% endblock %}

{% block section_saveOptions %}
#### 保存选项

`{{baseObjectName}}` 对象在保存时可以设置选项来快捷完成关联操作，可用的选项属性有：

选项 | 类型 | 适用操作 | 说明
--- | --- | --- | ---
{{ docs.nowrap(saveOptions_fetchWhenSave) }} | Boolean | create<br/>update |对象成功保存后，自动返回其在云端的最新值。create 操作返回该对象的所有属性，update 操作只返回被更新了的属性的最新值。用法请参考 [更新计数器](#更新计数器)。
`{{saveOptions_query}}` | {{baseQueryClassName}}  | update | 当 query 中的条件满足后，对象才能被更新，否则系统会放弃更新，并返回错误码 305。<br/><br/>通过 query 指定的条件仅对已存在的对象生效，如果用于保存新对象，则不生效。<br/><br/>开发者原本可以通过 `{{baseQueryClassName}}` 和 `{{baseObjectName}}` 分两步来实现这样的逻辑，但如此一来无法保证操作的原子性从而导致并发问题。该选项可以用来判断多用户更新同一对象数据时可能引发的冲突。用法请参考 [按条件更新对象](#按条件更新对象)。

### 获取对象
每个被成功保存在云端的对象会有一个唯一的 Id 标识 `{{objectIdName}}`，因此获取对象的最基本的方法就是根据 `{{objectIdName}}` 来查询：

{{ code_get_todo_by_objectId() }}

除了使用 `{{baseQueryClassName}}`，还可以采用在本地构建一个 `{{baseObjectName}}` 的方式，通过接口和 objectId 把数据从云端拉取到本地：

{% block code_fetch_todo_by_objectId %}{% endblock %}

#### 获取 objectId
每一次对象存储成功之后，云端都会返回 `{{objectIdName}}`，它是一个全局唯一的属性。

{% block code_save_callback_get_objectId %}{% endblock %}

{% block text_access_object_properties %}
#### 访问对象的属性
访问 Todo 的属性的方式为：

{% block code_access_todo_folder_properties %}{% endblock %}

请注意以上代码中访问三个特殊属性 `{{objectIdName}}`、`{{createdAtName}}`、`{{updatedAtName}}` 的方式。

如果访问了并不存在的属性，SDK 并不会抛出异常，而是会返回空值。

#### 默认属性
默认属性是所有对象都会拥有的属性，它包括 `{{objectIdName}}`、`{{createdAtName}}`、`{{updatedAtName}}`。

<dl>
  <dt>`{{createdAtName}}`</dt>
  <dd>对象第一次保存到云端的时间戳。该时间一旦被云端创建，在之后的操作中就不会被修改。</dd>
  <dt>`{{updatedAtName}}`</dt>
  <dd>对象最后一次被修改（或最近一次被更新）的时间。</dd>
</dl>

{{ data.localizedDates() }} 
{% endblock %}

{% block text_refresh_object%}
#### 同步对象
多终端共享一个数据时，为了确保当前客户端拿到的对象数据是最新的，可以调用刷新接口来确保本地数据与云端的同步：

{% block code_object_fetch %}{% endblock %}

在更新对象操作后，对象本地的 `{{updatedAtName}}` 字段（最后更新时间）会被刷新，直到下一次 save 操作，`{{updatedAtName}}` 的最新值才会被同步到云端，这样做是为了减少网络流量传输。

#### 同步指定属性

目前 Todo 这个类已有四个自定义属性：`priority`、`content`、`location` 和 `title`。为了节省流量，现在只想刷新 `priority` 和 `location` 可以使用如下方式：

{% block code_object_fetch_with_keys %}{% endblock %}

**刷新操作会强行使用云端的属性值覆盖本地的属性**。因此如果本地有属性修改，刷新操作会丢弃这些修改。

{% endblock %}

### 更新对象

{{productName}} 上的更新对象都是针对单个对象，云端会根据<u>有没有 objectId</u> 来决定是新增还是更新一个对象。

假如 `{{objectIdName}}` 已知，则可以通过如下接口从本地构建一个 `{{baseObjectName}}` 来更新这个对象：

{% block code_update_todo_content_with_objectId %}{% endblock %}

更新操作是覆盖式的，云端会根据最后一次提交到服务器的有效请求来更新数据。更新是字段级别的操作，未更新的字段不会产生变动，这一点请不用担心。

#### 按条件更新对象

通过使用 [保存选项](#保存选项) `query` 可以按照指定条件去更新对象——当条件满足时，执行更新；条件不满足时，不执行更新。

<a id="saveoption_query_example" name="saveoption_query_example"></a>例如：用户的账务账户表 `Account` 有一个余额字段 `balance`，同时有多个请求要修改该字段值，为避免余额出现负值，只有满足 **balance >= 当前请求的数值** 这个条件才允许修改，否则提示「余额不足，操作失败！」。

{% block code_saveoption_query_example %}{% endblock %}
{% endblock %}

#### 使用 CQL 语法更新对象
{{productName}} 提供了类似 SQL 语法中的 Update 方式更新一个对象，例如更新一个 TodoFolder 对象可以使用下面的代码：

{% block code_update_object_by_cql %}{% endblock %}

#### 更新计数器

这是原子操作（Atomic Operation）的一种。
为了存储一个整型的数据，{{productName}} 提供对任何数字字段进行原子增加（或者减少）的功能。比如一条微博，我们需要记录有多少人喜欢或者转发了它，但可能很多次喜欢都是同时发生的。如果在每个客户端都直接把它们读到的计数值增加之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准。此时就需要使用这类原子操作来实现计数器。

假如，现在增加一个记录查看 Todo 次数的功能，一些与他人共享的 Todo 如果不用原子操作的接口，很有可能会造成统计数据不准确，可以使用如下代码实现这个需求：

{% block code_atomic_operation_increment %}{% endblock %}

{% block text_atomic_operation_array %}
#### 更新数组

更新数组也是原子操作。使用以下方法可以方便地维护数组类型的数据：

{% block code_atomic_operation_array %}{% endblock %}

例如，Todo 对象有一个提醒时间 `reminders` 字段，是一个数组，代表这个日程会在哪些时间点提醒用户。比如有个拖延症患者把闹钟设为早上的 7:10、7:20、7:30：

{% block code_set_array_value %}{% endblock %}

{% endblock %}

### 删除对象

假如某一个 Todo 完成了，用户想要删除这个 Todo 对象，可以如下操作：

{% block code_delete_todo_by_objectId %}{% endblock %}

<div class="callout callout-danger">删除对象是一个较为敏感的操作。在控制台创建对象的时候，默认开启了权限保护，关于这部分的内容请阅读《[ACL 权限管理指南](acl-guide.html)》。</div>

#### 使用 CQL 语法删除对象
{{productName}} 提供了类似 SQL 语法中的 Delete 方式删除一个对象，例如删除一个 Todo 对象可以使用下面的代码：
{% block code_delete_todo_by_cql %}{% endblock %}

{% block section_delete_options %}
{% block code_delete_options %}{% endblock %}
{% endblock %}

{% block text_batch_operation %}
### 批量操作

为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 `{{baseObjectName}}` 这个类下面：

{% block code_batch_operation %}{% endblock %}

批量设置 Todo 已经完成：

{% block code_batch_set_todo_completed %}{% endblock %}

不同类型的批量操作所引发不同数量的 API 调用，具体请参考 [API 调用次数的计算](faq.html#API_调用次数的计算)。
{% endblock %}
{% block text_work_in_background %}
### 后台运行
细心的开发者已经发现，在所有的示例代码中几乎都是用了异步来访问 {{productName}} 云端，形如 `{{backgroundFunctionTemplate}}` 的方法都是提供给开发者在主线程调用用以实现后台运行的方法，因此开发者在主线程可以放心的调用这种命名方式的函数。另外，需要强调的是：**回调函数的代码是在主线程执行。**
{% endblock %}

{% block save_eventually %}
### 离线存储对象

大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 {{saveEventuallyName}} 来代替。

它的优点在于：如果用户目前尚未接入网络，{{saveEventuallyName}} 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，{{productName}} 会再次尝试保存操作。

所有 {{saveEventuallyName}}（或 {{deleteEventuallyName}}）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 {{saveEventuallyName}} 是安全的。

{% endblock %}

### 关联数据

#### `{{relationObjectName}}`（已弃用）

{{ docs.alert("以下文档仅供还在使用 Relation 的开发者做参考。对关联数据进行查询、排序等复杂操作，请使用 [中间表](relation-guide.html#使用中间表实现多对多关系_推荐_)。") }}

对象可以与其他对象相联系。如前面所述，我们可以把一个 `{{baseObjectName}}` 的实例 A，当成另一个 `{{baseObjectName}}` 实例 B 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像关系型数据库中的主外键关系一样。

例如，一个 TodoFolder 包含多个 Todo，可以用如下代码实现：

{% block code_relation_todoFolder_one_to_many_todo %}{% endblock %}

#### Pointer
Pointer 只是个描述并没有具象的类与之对应，它与 `{{relationObjectName}}` 不一样的地方在于：`{{relationObjectName}}` 是在**一对多**的「一」这一方（上述代码中的一指 TodoFolder）保存一个 `{{relationObjectName}}` 属性，这个属性实际上保存的是对被关联数据**多**的这一方（上述代码中这个多指 Todo）的一个 Pointer 的集合。而反过来，{{productName}} 也支持在「多」的这一方保存一个指向「一」的这一方的 Pointer，这样也可以实现**一对多**的关系。

简单的说， Pointer 就是一个外键的指针，只是在 LeanCloud 控制台做了显示优化。

现在有一个新的需求：用户可以分享自己的 TodoFolder 到广场上，而其他用户看见可以给与评论，比如某玩家分享了自己想买的游戏列表（TodoFolder 包含多个游戏名字），而我们用 Comment 对象来保存其他用户的评论以及是否点赞等相关信息，代码如下：

{% block code_pointer_comment_one_to_many_todoFolder %}{% endblock %}

##### 获取 Pointer 对象

当 Todo 拥有一个字段叫做 TodoFolder 的 Pointer 类型的属性，在获取 Todo 的对象的同时，想一并把被关联的 TodoFolder 也拉取到本地：

{% block code_pointer_include_todoFolder %}{% endblock %}

更多内容可参考 [关联数据查询](relation-guide.html#Pointers_查询)。

#### 地理位置
地理位置是一个特殊的数据类型，{{productName}} 封装了 `{{geoPointObjectName}}` 来实现存储以及相关的查询。

首先要创建一个 `{{geoPointObjectName}}` 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 `{{geoPointObjectName}}` 对象（LeanCloud 北京办公室所在地）：

{% block code_create_geoPoint %}{% endblock %}

假如，添加一条 Todo 的时候为该 Todo 添加一个地理位置信息，以表示创建时所在的位置：

{% block code_use_geoPoint %}{% endblock %}

同时请参考 [地理位置查询](#地理位置查询)。

{% block text_deserialize_and_serialize %}

### 序列化和反序列化
在实际的开发中，把 `{{baseObjectName}}` 当做参数传递的时候，会涉及到复杂对象的拷贝的问题，因此 `{{baseObjectName}}` 也提供了序列化和反序列化的方法：

序列化：
{% block code_serialize_baseObject_to_string %}{% endblock %}

反序列化：
{% block code_deserialize_string_to_baseObject %}{% endblock %}

{% endblock %}

{% block object_extra %}{% endblock %}

{% block text_data_protocol %}

### 数据协议
很多开发者在使用 {{productName}} 初期都会产生疑惑：客户端的数据类型是如何被云端识别的？
因此，我们有必要重点介绍一下 {{productName}} 的数据协议。

先从一个简单的日期类型入手，比如在 {{platform_name}} 中，默认的日期类型是 `{{dateType}}`，下面会详细讲解一个
 `{{dateType}}` 是如何被云端正确的按照日期格式存储的。

为一个普通的 `{{baseObjectName}}` 的设置一个 `{{dateType}}` 的属性，然后调用保存的接口：

{% block code_data_protocol_save_date %}{% endblock %}

{{sdk_name}} 在真正调用保存接口之前，会自动的调用一次序列化的方法，将 `{{dateType}}` 类型的数据，转化为如下格式的数据：

```json
{
  "__type": "Date",
  "iso": "2015-11-21T18:02:52.249Z"
}
```

然后发送给云端，云端会自动进行反序列化，这样自然就知道这个数据类型是日期，然后按照传过来的有效值进行存储。因此，开发者在进阶开发的阶段，最好是能掌握 {{productName}} 的数据协议。如下表介绍的就是一些默认的数据类型被序列化之后的格式：

{% block table_data_protocol %}

类型 | 序列化之后的格式|
---|---
`{{dateType}}` | `{"__type": "Date","iso": "2015-11-21T18:02:52.249Z"}`
`{{byteType}}` |  `{"__type": "Bytes","base64":"utf-8-encoded-string}"`
`Pointer` |`{"__type":"Pointer","className":"Todo","objectId":"55a39634e4b0ed48f0c1845c"}`
`{{relationObjectName}}`| `{"__type": "Relation","className": "Todo"}`
{% endblock %}

{% endblock %}

{% block text_LCType_convert %}
{% endblock %}
{% block module_file %}
## 文件
文件存储也是数据存储的一种方式，图像、音频、视频、通用文件等等都是数据的载体。很多开发者也习惯把复杂对象序列化之后保存成文件，比如 JSON 或 XML 文件。文件存储在 {{productName}} 中被单独封装成一个 `{{fileObjectName}}` 来实现文件的上传、下载等操作。

### 文件上传

文件上传是指开发者调用接口将文件存储在云端，并且返回文件最终的 URL 的操作。

文件上传成功后会在系统表 `_File` 中生成一条记录，**此后该记录无法被再次修改**，包括 [metaData 字段](#文件元数据) 中的数据。所以如需更新该文件的记录内容，只能重新上传文件，得到新的 id 和 URL。

如果 `_File` 表打开了 [删除权限](#删除)，该记录才可以被删除。

{% block text_create_avfile_by_stream_data %}
#### 从数据流构建文件
`{{fileObjectName}}` 支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据，在构建的时候，传入对应的数据流即可：

{% block code_create_avfile_by_stream_data %}{% endblock %}

上例将文件命名为 `resume.txt`，这里需要注意两点：

- 不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 `resume.txt` 的文件也不会有问题。
- 给文件添加扩展名非常重要。云端通过扩展名来判断文件类型，以便正确处理文件。所以要将一张 PNG 图片存到 `{{fileObjectName}}` 中，要确保使用 `.png` 扩展名。
{% endblock %}

{% block text_create_avfile_from_local_path %}
#### 从本地路径构建文件
大多数的客户端应用程序都会跟本地文件系统产生交互，常用的操作就是读取本地文件，如下代码可以实现使用本地文件路径构建一个 `{{fileObjectName}}`：

{% block code_create_avfile_from_local_path %}{% endblock %}

{% endblock %}

{% block text_create_avfile_from_url %}
#### 从网络路径构建文件
从一个已知的 URL 构建文件也是很多应用的需求。例如，从网页上拷贝了一个图像的链接，代码如下：

{% block code_create_avfile_from_url %}{% endblock %}

{% endblock %}

[从本地路径构建文件](#从本地路径构建文件) 会<u>产生实际上传的流量</u>，并且文件最后是存在云端，而 [从网络路径构建文件](#从网络路径构建文件) 的文件实体并不存储在云端，只是会把文件的物理地址作为一个字符串保存在云端。

{% block text_upload_file %}
#### 执行上传
上传的操作调用方法如下：

{% block code_upload_file %}{% endblock %}
{% endblock %}

{% block text_upload_file_with_progress %}
#### 上传进度监听
一般来说，上传文件都会有一个上传进度条显示用以提高用户体验：

{% block code_upload_file_with_progress %}{% endblock %}

{% endblock %}

{% block text_download_file_with_progress %}
### 文件下载
客户端 SDK 接口可以下载文件并把它缓存起来，只要文件的 URL 不变，那么一次下载成功之后，就不会再重复下载，目的是为了减少客户端的流量。

{% block code_download_file %}{% endblock %}
{% block text_download_progress %}请注意代码中**下载进度**数据的读取。{% endblock %}

{% endblock %}
{% if node !='qcloud' %}
### 图像缩略图

保存图像时，如果想在下载原图之前先得到缩略图，方法如下：

{% block code_file_image_thumbnail %}{% endblock %}

<div class="callout callout-info">图片最大不超过 **20 MB** 才可以获取缩略图。</div>

<div class="callout callout-danger">图片缩略图只支持华北节点的应用，华东和北美节点不支持。</div>

{% endif %}
### 文件元数据

`{{fileObjectName}}` 的 `metaData` 属性，可以用来保存和获取该文件对象的元数据信息。metaData 一旦保存到云端就**无法再次修改**。 

{% block code_file_metadata %}{% endblock %}

{# 2017-11-09 the following block doesn't apply to swift, php, python #}
{% if segment_code === 'objc' or segment_code === 'java' or segment_code === 'js' or segment_code === 'android' %}
### 关联文件

使用 `Pointer` 字段类型将 `AVFile` 关联到 AVObject 对象的一个字段上：

{% block file_as_avatar %}{% endblock %}

查询的时候需要额外的 `include` 一下：

{% block query_file_as_avatar %}{% endblock %}
{% endif %}

{% block text_file_query %}{% endblock %}

### 删除

当文件较多时，要把一些不需要的文件从云端删除：

<div class="callout callout-danger">默认情况下，文件的删除权限是关闭的，需要进入 [控制台 > 存储 > **`_File`**](/dashboard/data.html?appid={{appid}}#/_File)，选择菜单 **其他** > **权限设置** > **delete** 来开启。</div>

{% block code_file_delete %}{% endblock %}

{% block code_cache_operations_file %}{% endblock %}

### 启用 HTTPS 域名

如果希望使用 HTTPS 域名来访问文件，需要进入 [控制台 > 存储 > 设置 > 文件](/dashboard/storage.html?appid={{appid}}#/storage/conf)，勾选 **启用 https 域名**。HTTPS 文件流量无免费的使用额度，收费标准将在该选项开启时显示。

{{ docs.alert("「启用 https 域名」会影响到 API 返回的文件地址是 HTTPS 还是 HTTP 类型的 URL。需要注意的是，即使没有启用这一选项，终端仍然可以选择使用 HTTPS URL 来访问文件，但由此会产生 HTTPS 流量扣费。") }}

在启用文件 HTTPS 域名之后，之前已保存在 `_File` 表中的文件的 URL 会自动被转换为以 HTTPS 开头。如果取消 HTTPS 域名，已经改为 HTTPS 域名的文件不会变回到 HTTP。

<a id="rtm-http-urls" name="rtm-http-urls"></a>LeanCloud 即时通讯组件也使用 `AVFile` 来保存消息的图片、音频等文件，并且把文件的地址写入到了消息内容中。当文件 HTTPS 域名被开启后，之前历史消息中的文件地址不会像 `_File` 表那样被自动转换，而依然保持 HTTP。

{% block text_http_access_for_ios9andup %}{% endblock %}

### 设置自定义文件域名

LeanCloud 提供公用的二级域名来让开发者及其用户能够便捷地访问到存储在云端的文件。但由于受网络法规的管控与限制，我们无法 100% 保证该公用域名随时可用。因此，强烈建议开发者**使用自定义域名来访问自己的文件**，以避免公用域名不可用之时应用的体验会受到影响。请前往 [存储 > 设置 > 文件](/dashboard/storage.html?appid={{appid}}#/storage/conf) 设置自定义域名。

注意，绑定域名的操作是不可逆的。绑定域名后无法取消绑定，但可以更换绑定的域名。

### CDN 加速

{{ data.cdn(true) }}

{% endblock %}

## 查询
`{{baseQueryClassName}}` 是构建针对 `{{baseObjectName}}` 查询的基础类。{{query_result_limit}}

### 示例数据结构

熟悉本文所使用的相关数据表结构将有助于更好地理解后面的内容。

![](images/todo-schema.svg)

#### Todo（待办事项）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `content` | String | 事项的详细内容 |
| `images` | AVFile | 与事项相关的图片 |
| `location` | String | 处理该事项的地点 |
| `priority` | Number | 0 优先级最高，最迫切需要完成。 |
| `reminders` | Array | 设置提醒日期和时间 |
| `status` | Number | 0 未完成，1 已完成 |
| `title` | String | 事项的标题（简短描述） |
| `views` | Number | 该事项被浏览过的次数 |
| `whereCreated` | AVGeoPoint | 该事项被创建时的地理定位 |

#### TodoFolder（待办事项的分组）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `containedTodos` | Relation | 所包含的 Todo，与表 `Todo` 相关联。 |
| `name` | String | 分组的名称，如家庭、会议。 |
| `owner` | Pointer | 分组的所有者或创建人，指向表 `_User` |
| `priority` | Number | 该分组的优先级别，0 优先级最高。 |
| `tags` | Relation | 标签，与表 `Tag` 相关联。 |

#### Comment（待办事项分组的评论）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `content` | String | 评论的内容 |
| `likes` | Number | 点了赞就是 1，点了不喜欢为 -1，没有做任何操作就为 0（默认）。 |
| `targetTodoFolder` | Pointer | 相关联的待办事项分组，指向表 `TodoFolder` 的 objectId |

#### Tag（待办事项分组的标签）

| 字段 | 类型 | 说明 |
| :-- | :-- | :-- |
| `name` | String | 标签的名称，如今日必做、老婆吩咐、十分重要等。 |
| `targetTodoFolder` | Pointer | 相关联的待办事项分组，指向表 `TodoFolder` 的 objectId |

{% block text_avquery_constructors %}
### 创建查询实例
{% block code_create_query_by_className %}{% endblock %}

{% endblock %}

最基础的用法是根据 objectId 来查询对象：

{{ code_get_todo_by_objectId() }}

### 比较查询

{% block table_logic_comparison_in_query %}{% endblock %}

利用上述表格介绍的逻辑操作的接口，我们可以很快地构建条件查询。

例如，查询优先级小于 2 的所有 Todo ：

{% block code_query_lessThan %}{% endblock %}

<div class="callout callout-info">{{query_result_limit}}</div>

以上逻辑用 SQL 语句表达为 `select * from Todo where priority < 2`。{{productName}} 也支持使用这种传统的 SQL 语句查询。具体使用方法请移步至 [CQL 查询](#CQL_查询)。

查询优先级大于等于 2 的 Todo：

{% block code_query_greaterThanOrEqualTo %}{% endblock %}

#### 查询备选范围内满足条件的值

当我们要查询的属性值，存在一个可选集合的时候，可以使用 `containedIn` 来进行查询。

例如每一个 `Todo` 条目，有一个名为 `location` 的字符串属性，指示完成的地点。我们要查询在 `Office` 或者 `CoffeeShop` 完成的待办事项，则可以：

{% block code_query_with_containedIn_keyword %}containedIn{% endblock %}

#### 多个查询条件

当多个查询条件并存时，它们之间默认为 AND 关系，即查询只返回满足了全部条件的结果。建立 OR 关系则需要使用 [组合查询](#组合查询)。

在**简单查询**中，如果对一个对象的**同一属性**设置多个条件，那么先前的条件会被覆盖，查询只返回满足最后一个条件的结果。例如要找出优先级为 0 和 1 的所有 Todo，错误写法是：

{% block code_priority_equalTo_zero_and_one_wrong_example %}{% endblock %}

正确作法是使用 [组合查询 · OR 关系](#OR_查询) 来构建这种条件。


### 字符串查询

**前缀查询**类似于 SQL 的 `LIKE 'keyword%'` 条件。因为支持索引，所以该操作对于大数据集也很高效。

{% block code_query_whereHasPrefix %}{% endblock %}

**包含查询**类似于 SQL 的 `LIKE '%keyword%'` 条件，比如查询标题包含「李总」的 Todo：

{% block code_query_with_contains_keyword %}whereContains{% endblock %}

**不包含查询**可以使用**正则匹配查询**的方式来实现。例如，查询标题不包含「机票」的 Todo：

{% block code_query_with_not_contains_keyword_using_regex %}正则表达式{% endblock %}

<div class="callout callout-info">正则匹配查询**只适用于**字符串类型的数据。</div>

但是基于正则的模糊查询有两个缺点：

- 当数据量逐步增大后，查询效率将越来越低。
- 没有文本相关性排序

因此我们推荐使用 [应用内搜索](#应用内搜索) 功能。它基于搜索引擎技术构建，提供更强大的搜索功能。

### 数组查询

当一个对象有一个属性是数组的时候，针对数组的元数据查询可以有多种方式。例如，在 [数组](#更新数组) 一节中我们为 Todo 设置了 reminders 属性，它就是一个日期数组，现在我们需要查询所有在 8:30 会响起闹钟的 Todo 对象：

{% block code_query_array_contains_using_equalsTo %}{% endblock %}

查询包含 8:30 和 9:30 这两个时间点响起闹钟的 Todo：

{% block code_query_array_contains_all %}{% endblock %}

注意这里是包含关系，假如有一个 Todo 会在 8:30、9:30 和 10:30 响起闹钟，它仍然是会被查询出来的。


查询「全不包含」的情况：

{% block code_query_with_not_contains_keyword %}notContainedIn{% endblock %}

查询「部分包含（指查询的数组属性中，包含有目标集合的部分元素）」的情况：

{% block code_query_with_part_contains_keyword %}partialContainedIn{% endblock %}


### 空值查询

假设用户可以有选择地为 Todo 上传图片来做标注，要想找出那些已有图片的 Todo：

{% block code_query_where_keys_exist %}{% endblock %}

### 关系查询
关联数据查询也可以通俗地理解为关系查询，关系查询在传统型数据库的使用中是很常见的需求，因此我们也提供了相关的接口来满足开发者针对关联数据的查询。

首先，我们需要明确关系的存储方式，再来确定对应的查询方式。

#### Pointer 查询
基于在 [Pointer](#Pointer) 小节介绍的存储方式：每一个 Comment 都会有一个 TodoFolder 与之对应，用以表示 Comment 属于哪个 TodoFolder。现在我已知一个 TodoFolder，想查询所有的 Comnent 对象，可以使用如下代码：

{% block code_query_comment_by_todoFolder %}{% endblock %}

#### `{{relationObjectName}}` 查询
假如用户可以给 TodoFolder 增加一个 Tag 选项，用以表示它的标签，而为了以后拓展 Tag 的属性，就新建了一个 Tag 对象，如下代码是创建 Tag 对象：

{% block code_create_tag_object %}{% endblock %}

而 Tag 的意义在于一个 TodoFolder 可以拥有多个 Tag，比如「家庭」（TodoFolder） 拥有的 Tag 可以是：今日必做、老婆吩咐、十分重要。实现创建「家庭」这个 TodoFolder 的代码如下：

{% block code_create_family_with_tag %}{% endblock %}

查询一个 TodoFolder 的所有 Tag 的方式如下：

{% block code_query_tag_for_todoFolder %}{% endblock %}

反过来，现在已知一个 Tag，要查询有多少个 TodoFolder 是拥有这个 Tag 的，可以使用如下代码查询：

{% block code_query_todoFolder_with_tag %}{% endblock %}

关于关联数据的建模是一个复杂的过程，很多开发者因为在存储方式上的选择失误导致最后构建查询的时候难以下手，不但客户端代码冗余复杂，而且查询效率低，为了解决这个问题，我们专门针对关联数据的建模推出了一个详细的文档予以介绍，详情请阅读《[数据模型设计指南](relation-guide.html)》。

#### 关联属性查询
正如在 [Pointer](#Pointer) 中保存 Comment 的 targetTodoFolder 属性一样，假如查询到了一些 Comment 对象，想要一并查询出每一条 Comment 对应的 TodoFolder 对象的时候，可以加上 include 关键字查询条件。同理，假如 TodoFolder 表里还有 pointer 型字段 targetAVUser 时，再加上一个递进的查询条件，形如 include(b.c)，即可一并查询出每一条 TodoFolder 对应的 AVUser 对象。代码如下：

{% block code_query_comment_include_todoFolder %}{% endblock %}

此外需要格外注意的是，假设对象有一个 Array 类型的字段 `todoArray` 内部是 Pointer 类型：
```
[pointer1, pointer2, pointer3]
```
可以用 include 方法获取数组中的 pointer 数据，例如：

```objc
[query includeKey:@"todoArray"];
```
```java
query.include("todoArray");
```
```js
query.include('todoArray');
```

但是 Array 类型的 include 操作只支持到第一层，不支持 `include(b.c)` 这种递进关联查询。

`select` 也具备使用 dot 符号 `.` 来进行级联操作：

```objc
[query selectKeys:@"targetTodoFolder.targetAVUser.username"];
```
```java
query.selectKeys(Arrays.asList("targetTodoFolder.targetAVUser.username"));
```
```js
query.select(['targetTodoFolder.targetAVUser.username']);
```

#### 内嵌查询

查询被打上某一个 Tag 的 TodoFolder 的所有 Comment 评论（注意查询针对的是 [Comment](#Comment_待办事项分组的评论_)），使用内嵌查询接口就可以通过一次查询来达到目的。

{% block code_query_comment_match_query_todoFolder %}{% endblock %}

与普通查询一样，内嵌查询默认也最多返回 100 条记录，想修改这一默认请参考 [限定结果返回数量](#限定返回数量)。

**如果所有返回的记录没有匹配到外层的查询条件，那么整个查询也查不到结果**。例如：

{{ data.innerQueryLimitation(description="", skip="[skip](#跳过数量)") }}

### 地理位置查询
地理位置查询是较为特殊的查询，一般来说，常用的业务场景是查询距离 xx 米之内的某个位置或者是某个建筑物，甚至是以手机为圆心，查找方圆多少范围内餐厅等等。{{productName}} 提供了一系列的方法来实现针对地理位置的查询。

#### 查询位置附近的对象
Todo 的 `whereCreated`（创建 Todo 时的位置）是一个 `{{geoPointObjectName}}` 对象，现在已知了一个地理位置，现在要查询 `whereCreated` 靠近这个位置的 Todo 对象可以使用如下代码：

{% block code_query_geoPoint_near %}{% endblock %}

#### 查询指定范围内的对象
要查找指定距离范围内的数据，可使用 `whereWithinKilometers` 、 `whereWithinMiles` 或 `whereWithinRadians` 方法。
例如，我要查询距离指定位置，2 千米范围内的 Todo：

{% block code_query_geoPoint_within %}{% endblock %}

#### 注意事项

使用地理位置需要注意以下方面：

* 每个 `{{baseObjectName}}` 数据对象中只能有一个 `{{geoPointObjectName}}` 对象的属性。
* 地理位置的点不能超过规定的范围。纬度的范围应该是在 `-90.0` 到 `90.0` 之间，经度的范围应该是在 `-180.0` 到 `180.0` 之间。如果添加的经纬度超出了以上范围，将导致程序错误。
{% block text_platform_geoPoint_notice %}{% endblock %}

### 组合查询
组合查询就是把诸多查询条件合并成一个查询，再交给 SDK 去云端查询。方式有两种：OR 和 AND。

#### OR 查询
OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级是大于等于 3 或者已经完成了的 Todo：

{% block code_query_with_or %}{% endblock %}

**注意：OR 查询中，子查询中不能包含地理位置相关的查询。**

#### AND 查询
AND 操作将满足了所有查询条件的对象返回给客户端。例如，找到创建于 `2016-11-13` 至 `2016-12-02` 之间的 Todo：

{% block code_query_with_and %}{% endblock %}

可以对新创建的 `{{baseQueryClassName}}` 添加额外的约束，多个约束将以 AND 运算符来联接。

### 查询结果数量和排序

#### 获取第一条结果
例如很多应用场景下，只要获取满足条件的一个结果即可，例如获取满足条件的第一条 Todo：

{% block code_query_find_first_object %}{% endblock %}

#### 限定返回数量
为了防止查询出来的结果过大，云端默认针对查询结果有一个数量限制，即 `limit`，它的默认值是 100。比如一个查询会得到 10000 个对象，那么一次查询只会返回符合条件的 100 个结果。`limit` 允许取值范围是 1 ~ 1000。例如设置返回 10 条结果：

{% block code_set_query_limit %}{% endblock %}

#### 跳过数量
设置 skip 这个参数可以告知云端本次查询要跳过多少个结果。将 skip 与 limit 搭配使用可以实现翻页效果。例如，在翻页中每页显示数量为 10，要获取第 3 页的对象：

{% block code_set_skip_for_pager %}{% endblock %}

上述方法的执行效率比较低，因此不建议广泛使用。**建议选用 `{{createdAtName}}` 或者 `{{updatedAtName}}` 这类的时间戳进行[分段查询](faq.html#查询结果默认最多只能返回 1000 条数据，当我需要的数据量超过了-1000-该怎么办？)**。

#### 返回指定属性/字段
通常列表展现的时候并不是需要展现某一个对象的所有属性，例如，Todo 这个对象列表一般展现的是 title 以及 content，在设置查询时可以告知云端需要返回的属性或字段有哪些，这样既满足需求又节省流量，还可以提高一部分的性能：

{% block code_query_select_keys %}{% endblock %}

所指定的属性或字段也支持 Pointer 类型。例如，获取 Todo 这个对象的所有者信息（owner 属性，Pointer 类型），仅展示这个所有者的 username：

{% block code_query_select_pointer_keys %}{% endblock %}

#### 统计总数量
通常用户在执行完搜索后，结果页面总会显示出诸如「搜索到符合条件的结果有 1020 条」这样的信息。例如，查询一下今天一共完成了多少条 Todo：

{% block code_query_count %}{% endblock %}

#### 排序

对于数字、字符串、日期类型的数据，可对其进行升序或降序排列。

{% block code_query_orderby %}{% endblock %}

一个查询可以附加多个排序条件，如按 priority 升序、createdAt 降序排列：

{% block code_query_orderby_on_multiple_keys %}{% endblock %}

<!-- #### 限定返回字段 -->

### CQL 查询
CQL 是 {{productName}} 独创的使用类似 SQL 语法来实现云端查询功能的语言，具有 SQL 开发经验的开发者可以方便地使用此接口实现查询。

分别找出 status = 1 的全部 Todo 结果，以及 priority = 0 的 Todo 的总数：

{% block code_query_by_cql %}{% endblock %}

通常查询语句会使用变量参数，为此我们提供了与 Java JDBC 所使用的 PreparedStatement 占位符查询相类似的语法结构。

查询 status = 0、priority = 1 的 Todo：

{% block code_query_by_cql_with_placeholder %}{% endblock %}

目前 CQL 已经支持数据的更新 update、插入 insert、删除 delete 等 SQL 语法，更多内容请参考 [CQL 详细指南](cql_guide.html)。

{% block text_query_cache_intro %}
### 缓存查询
缓存一些查询的结果到磁盘上，这可以让你在离线的时候，或者应用刚启动，网络请求还没有足够时间完成的时候可以展现一些数据给用户。当缓存占用了太多空间的时候，{{productName}} 会自动清空缓存。

默认情况下的查询不会使用缓存，除非你调用接口明确设置启用。例如，尝试从网络请求，如果网络不可用则从缓存数据中获取，可以这样设置：

{% block code_set_cache_policy %}{% endblock %}

#### 缓存策略
为了满足多变的需求，SDK 默认提供了以下几种缓存策略：

{% block table_cache_policy %}{% endblock %}

#### 缓存相关的操作
{% block code_cache_operation %}{% endblock %}

{% endblock %}

### 查询性能优化

影响查询性能的因素很多。特别是当查询结果的数量超过 10 万，查询性能可能会显著下降或出现瓶颈。以下列举一些容易降低性能的查询方式，开发者可以据此进行有针对性的调整和优化，或尽量避免使用。

- 不等于和不包含查询（无法使用索引）
- 通配符在前面的字符串查询（无法使用索引）
- 有条件的 count（需要扫描所有数据）
- skip 跳过较多的行数（相当于需要先查出被跳过的那些行）
- 无索引的排序（另外除非复合索引同时覆盖了查询和排序，否则只有其中一个能使用索引）
- 无索引的查询（另外除非复合索引同时覆盖了所有条件，否则未覆盖到的条件无法使用索引，如果未覆盖的条件区分度较低将会扫描较多的数据）

{% block text_js_promise %}{% endblock %}

## 用户

用户系统几乎是每款应用都要加入的功能。除了基本的注册、登录和密码重置，移动端开发还会使用手机号一键登录{% if node != 'qcloud' and node != 'us' %}、短信验证码登录{% endif %}等功能。{{productName}} 提供了一系列接口来帮助开发者快速实现各种场景下的需求。

`{{userObjectName}}` 是用来描述一个用户的特殊对象，与之相关的数据都保存在 `_User` 数据表中。

### 用户的属性

#### 默认属性
用户名、密码、邮箱是默认提供的三个属性，访问方式如下：

{% block code_get_user_properties %}{% endblock %}

请注意代码中，密码是仅仅是在注册的时候可以设置的属性（这部分代码可参照 [用户名和密码注册](#用户名和密码注册)），它在注册完成之后并不会保存在本地（SDK 不会以明文保存密码这种敏感数据），所以在登录之后，再访问密码这个字段是为**空的**。

#### 自定义属性

用户对象和普通对象一样也支持添加自定义属性。例如，为当前用户添加年龄属性 `age`：

{% block code_set_user_custom_properties %}{% endblock %}

#### 修改属性

很多开发者会有这样的疑问：「为什么我不能修改任意一个用户的属性？」

>因为很多时候，就算是开发者也不要轻易修改用户的基本信息，例如用户的手机号、社交账号等个人信息都比较敏感，应该由用户在 App 中自行修改。所以为了保证用户的数据仅在用户自己已登录的状态下才能修改，云端对所有针对 `{{userObjectName}}` 对象的数据操作都要做验证。

例如，先为当前用户增加一个 age 属性，保存后再更改它的值：

{% block code_update_user_custom_properties %}{% endblock %}

`{{userObjectName}}` 的自定义属性在使用上与 `{{baseObjectName}}` 没有本质区别。

### 注册

{% block text_send_sms_code_for_loginOrSignup %}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号码注册

一些应用为了提高首次使用的友好度，一般会允许用户浏览一些内容，直到用户发起了一些操作才会要求用户输入一个手机号，而云端会自动发送一条验证码的短信给用户的手机号，最后验证一下，完成一个用户注册并且登录的操作，例如很多团购类应用都有这种用户场景。

首先调用发送验证码的接口：

{% block code_send_sms_code_for_loginOrSignup %}{% endblock %}

然后在 UI 上给与用户输入验证码的输入框，用户点击登录的时候调用如下接口：

{% block code_verify_sms_code_for_loginOrSignup %}{% endblock %}

{% endif %}
{% endblock %}
#### 用户名和密码注册

采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文存储密码，并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过控制台还是 API 都是无法获取。另外我们需要强调<u>在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效</u>。

例如，注册一个用户的示例代码如下（用户名 `Tom` 密码 `cat!@#123`）：

{% block code_user_signUp_with_username_and_password %}{% endblock %}

{% block text_using_async_methods %}
我们建议在可能的情况下尽量使用异步版本的方法，这样就不会影响到应用程序主 UI 线程的响应。
{% endblock %}

如果注册不成功，请检查一下返回的错误对象。最有可能的情况是用户名已经被另一个用户注册，错误代码 [202](error_code.html#_202)，即 `_User` 表中的 `username` 字段已存在相同的值，此时需要提示用户尝试不同的用户名来注册。同样，邮件 `email` 和手机号码 `mobilePhoneNumber` 字段也要求在各自的列中不能有重复值出现，否则会出现 [203](error_code.html#_203)、[214](error_code.html#_214) 错误。

开发者也可以要求用户使用 Email 做为用户名注册，即在用户提交信息后将 `_User` 表中的 `username` 和 `email` 字段都设为相同的值，这样做的好处是用户在忘记密码的情况下可以直接使用「[邮箱重置密码](#重置密码)」功能，无需再额外绑定电子邮件。

{{link_to_blog_password_reset}}

{% block sns_authdata %}{% endblock %}

{% if node != 'qcloud' and node != 'us' %}
#### 设置手机号码

微信、陌陌等流行应用都会建议用户将账号和一个手机号绑定，这样方便进行身份认证以及日后的密码找回等安全模块的使用。我们也提供了一整套发送短信验证码以及验证手机号的流程，这部分流程以及代码演示请参考 {{ sms_guide_url }}。
{% endif %}

#### 验证邮箱

许多应用会通过验证邮箱来确认用户注册的真实性。如果在 {{app_permission_link}} 中勾选了 **用户注册时，发送验证邮件**，那么当一个 `AVUser` 在注册时设置了邮箱，云端就会向该邮箱自动发送一封包含了激活链接的验证邮件，用户打开该邮件并点击激活链接后便视为通过了验证。

有些用户可能在注册之后并没有点击激活链接，而在未来某一个时间又有验证邮箱的需求，这时需要调用如下接口让云端重新发送验证邮件：

{% block code_send_verify_email %}{% endblock %}

当用户 `AVUser` 通过 `setEmail()` 更新成一个新邮箱并成功 save 后，云端会自动向新邮箱发一封验证邮件，因此开发者**不需要**再单独调用 `requestEmailVerify` 接口来发送验证邮件。

### 登录

我们提供了多种登录方式，以满足不同场景的应用。

#### 用户名和密码登录

{% block code_user_logIn_with_username_and_password %}{% endblock %}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号和密码登录

{{ sms_guide_url }} 可以帮助你更好地理解手机号匹配密码登录的流程以及适用范围，所以推荐详细阅读。

{% block code_user_logIn_with_mobilephonenumber_and_password %}{% endblock %}

以上的手机号码即使没有经过验证，只要密码正确也可以成功登录。如果希望阻止未验证的手机号码用于登录，则需要在 {{app_permission_link}} 中勾选 **未验证手机号码的用户，禁止登录**。这种方式也提高了用户账号的合法性与安全性。

#### 手机号和验证码登录

首先，调用发送登录验证码的接口：

{% block code_user_logIn_requestLoginSmsCode %}{% endblock %}

然后在界面上引导用户输入收到的 6 位短信验证码：

{% block code_user_logIn_with_smsCode %}{% endblock %}

{% endif %}

{% block text_current_user %}

{{ sms.fixedVerificationCode("####") }}

#### 单设备登录

如果想实现在当前设备 A 上登录后，强制令之前在其他设备上的登录失效，可以按照以下方案来实现：
{# 2017-09-20 hide method 1
**方案一**：

1. 设备 A 登录成功后，调用 AVUser 的 `refreshSessionToken` 方法，更新服务端的 sessionToken。
2. 设备 B 中的应用启动时，调用 AVUser 的 `isAuthenticated` 方法。由于上一步的操作，此时设备 B 中的 sessionToken 是过期的，因此该方法会返回 false，然后据此来调用 `logout` 方法退出登录。
3. 设备 B 中的应用假设正在使用的过程中，A 设备登录了，B 可能会因为发送请求而接收到错误码为 `403(Forbidden to read/write by class permissions)` 的响应，那么基本可以判断出当前用户的 sessionToken 过期了，此时也应将用户导航到登录页面重新登录。


**方案二**：
#}
1. 建立一个设备表，记录用户登录信息和当前设备的信息。
2. 设备 A 登录成功后，更新设备表，将当前设备标记为当前用户登录的最新设备。
3. 设备 B 中的应用启动时，检查设备表，发现最新设备不是当前设备，调用 AVUser 的 `logout` 方法退出登录。

{# 2017-09-21 hide step 4
1. 集成 [LiveQuery 用户登录事件][livequery-event-login]，当设备 B 收到当前用户的登录事件时，检查最新设备不是当前设备，调用 AVUser 的 logout 方法退出当前登录。
#}

{#
{{ docs.note("较之方案一，方案二要多维护一张设备表，步骤稍繁琐，适用于不具备 `refreshSessionToken` 方法的 SDK。") }}
#}
#### 当前用户

打开微博或者微信，它不会每次都要求用户都登录，这是因为它将用户数据缓存在了客户端。
同样，只要是调用了登录相关的接口，LeanCloud SDK 都会自动缓存登录用户的数据。
例如，判断当前用户是否为空，为空就跳转到登录页面让用户登录，如果不为空就跳转到首页：

{% block code_current_user %}{% endblock %}

{% block text_current_user_remains_if_not_being_logged_out %}
如果不调用 [登出](#登出) 方法，当前用户的缓存将永久保存在客户端。
{% endblock %}

#### SessionToken

所有登录接口调用成功之后，云端会返回一个 SessionToken 给客户端，客户端在发送 HTTP 请求的时候，{{sdk_name}} 会在 HTTP 请求的 Header 里面自动添加上当前用户的 SessionToken 作为这次请求发起者 `{{userObjectName}}` 的身份认证信息。

如果在 {{app_permission_link}} 中勾选了 **密码修改后，强制客户端重新登录**，那么当用户密码再次被修改后，已登录的用户对象就会失效，开发者需要使用更改后的密码重新调用登录接口，使 SessionToken 得到更新，否则后续操作会遇到 [403 (Forbidden)](error_code.html#_403) 的错误。

{% block text_user_isAuthenticated %}
##### 验证 SessionToken 是否在有效期内

{% block code_user_isAuthenticated %}{% endblock %}

{% endblock %}

{% block text_authenticate_via_sessiontoken %}
##### 使用 SessionToken 登录

在没有用户名密码的情况下，客户端可以使用 SessionToken 来登录。常见的使用场景有：

- 应用内根据以前缓存的 SessionToken 登录
- 应用内的某个页面使用 WebView 方式来登录 LeanCloud 
- 在服务端登录后，返回 SessionToken 给客户端，客户端根据返回的 SessionToken 登录。

{% block code_authenticate_via_sessiontoken %}
```javascript
// 1. getSessionToken()
// 2. become(sessionToken)
// 3. 在成功的回调中更新 currentUser 的信息 become(sessionToken)
```
{% endblock %}

{{ docs.alert("请避免在外部浏览器使用 URL 来传递 SessionToken，以防范信息泄露风险。") }}
{# 参见 [云引擎 · SDK 调用云函数](leanengine_cloudfunction_guide-node.html#) #}
{% endblock %}


#### 账户锁定

输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 `{"code":1,"error":"登录失败次数超过限制，请稍候再试，或者通过忘记密码重设密码。"}`，开发者可在客户端进行必要提示。

锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。



### 重置密码

#### 邮箱重置密码

我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。

重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：

{% block code_reset_password_by_email %}{% endblock %}

密码重置流程如下：

1. 用户输入注册的电子邮件，请求重置密码；
2. {{productName}} 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；
3. 用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；
4. 用户的密码已被重置为新输入的密码。

{{link_to_blog_password_reset}}

{% if node != 'qcloud' and node != 'us' %}
#### 手机号码重置密码

与使用 [邮箱重置密码](#邮箱重置密码) 类似，「手机号码重置密码」使用下面的方法来获取短信验证码：

{% block code_reset_password_by_mobilephoneNumber %}{% endblock %}

注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：

{% block code_reset_password_by_mobilephoneNumber_verify %}{% endblock %}
{% endif %}
### 登出

用户登出系统时，SDK 会自动清理缓存信息。

{% block code_current_user_logout %}{% endblock %}

{% endblock %}
### 用户的查询

为了安全起见，**新创建的应用的 `_User` 表默认关闭了 find 权限**，这样每位用户登录后只能查询到自己在 `_User` 表中的数据，无法查询其他用户的数据。如果需要让其查询其他用户的数据，建议单独创建一张表来保存这类数据，并开放这张表的 find 查询权限。

设置数据表权限的方法，请参考 [数据与安全 {{middot}} Class 级别的权限](data_security.html#Class_级别的_ACL)。我们推荐开发者在 [云引擎](leanengine_overview.html) 中封装用户查询，只查询特定条件的用户，避免开放 `_User` 表的全部查询权限。

查询用户代码如下：
{% block code_query_user %}{% endblock %}

### 匿名用户

将数据与用户关联需要首先创建一个用户，但有时你不希望强制用户在一开始就进行注册。使用匿名用户，可以让应用不提供注册步骤也能创建用户：

{% block anonymous_user_login %}{% endblock %}

{% block anonymous_user_save %}
如果有需要，应用还可以让用户通过下面的方法将匿名用户转化为普通用户：

- 设置用户名、密码后注册
- [关联第三方平台](#第三方账户登录)

以设置用户名、密码后注册为例：
{% block setup_username_and_password_for_anonymous_user %}{% endblock %}

判断一个用户是否是匿名用户：

{% block determine_a_user_is_anonymous %}{% endblock %}

匿名用户如果没有转化为普通用户，一旦登出就无法再次以该用户身份登录，与该用户关联的数据也将无法访问。
{% endblock %}

## 角色
关于用户与角色的关系，我们有一个更为详尽的文档介绍这部分的内容，并且针对权限管理有深入的讲解，详情请阅读《[ACL 权限管理指南](acl-guide.html)》。

{% block text_subclass %}{% endblock %}

{% if node != 'qcloud' %}
{% block text_sns %}
## 第三方账户登录

第三方登录是应用常见的功能。它直接使用第三方平台（如微信、QQ）已有的账户信息来完成新用户注册，这样不但简化了用户注册流程的操作，还提升了用户体验。

开发此功能的主要步骤有：

1. 配置平台账号
2. 开发者从第三方获取账户的授权信息 authData；
3. 把 authData 和 LeanCloud 的用户体系 AVUser 进行绑定。

### 常规开发流程介绍

#### 配置平台账号

在 [LeanCloud 应用控制台 > 组件 > 社交](/dashboard/devcomponent.html?appid={{appid}}#/component/sns) 配置相应平台的 **应用 ID** 和 **应用 Secret Key** 。点击保存，自动生成 **回调 URL** 和 **登录 URL**。

以微博开放平台举例，它需要单独配置 **回调 URL**。 在微博开放平台的 **应用信息** > **高级信息** > **OAuth2.0 授权设置** 里的「授权回调页」中绑定生成的 **回调 URL**。测试阶段，在微博开放平台的 **应用信息** > **测试信息** 添加微博账号，在腾讯开放平台的 **QQ 登录** > **应用调试者** 里添加 QQ 账号即可。在应用通过审核后，可以获取公开的第三方登录能力。

配置平台账号的目的在于创建 AVUser 时，LeanCloud 云端会使用相关信息去校验 authData 的合法性，确保 AVUser 实际对应着一个合法真实的用户，确保平台安全性。如果想关闭自动校验 authData 的功能，需要在 [应用控制台 > 组件 > 社交](/dashboard/devcomponent.html?appid={{appid}}#/component/sns)中**取消勾选**「第三方登录时，验证用户 AccessToken 合法性」。

#### 获取 authData 并创建 AVUser

LeanCloud **暂不提供** 获取第三方 authData 的 SDK。开发者需要调用微信、QQ 等官方的 SDK，并根据其文档进行获取，也可以使用其他服务商提供的社交登录组件。

开发者在获取了第三方的完整 authData 后，就可以使用我们提供的 AVUser 类的 `loginWithauthData` 或 `associateWithauthData` 两个接口，传入 authData，进行用户数据的绑定了。在操作成功之后，这部分第三方账户数据会存入 `_User` 表的 `authData` 字段里。

LeanCloud 后端要求 authData 至少含有 `openid 或 uid`、`access_token` 和 `expires_in` 三个字段。微信和 QQ 使用 `openid`，其他平台使用 `uid`。

如果是新用户，则生成一个新的 AVUser 并登录。示例代码如下：

{% block login_with_authdata %}{% endblock %}

成功后，在你的控制台的 _User 表里会生成一条新的 AVUser，它的数据格式如下：

{% block login_with_authdata_result %}{% endblock %}

如果是已有用户，则返回对应 authData 的 AVUser 实例并登录。

用户已经有了 AVUser 并登录成功后，可以用这个接口绑定新的第三方账号信息。绑定成功后，新的第三方账户信息会被添加到 AVUser 的 authData 字段里。示例代码如下：

{% block associate_with_authdata %}{% endblock %}

`_User` 表的对应 AVUser 数据的 authData 字段会新增一个 qq 的数据，如下：

{% block associate_with_authdata_result %}{% endblock %}

以上就是一个第三方登录开发的基本流程。

### 扩展需求

#### 新用户登录时必须填用户信息

满足需求：一个新用户使用第三方账号授权拿到相关信息后，仍然需要设置账号相关的用户名、手机号、密码等重要信息后，才被允许登录成功。

这时要使用 `loginWithauthData` 登录接口的 `failOnNotExist` 参数并将其设置为 ture。服务端会判断是否已存在能匹配上的 authData，否的话，返回 211 错误码和 `Could not find user` 报错信息。开发者根据这个 211 错误码，跳转到要求输入用户名、密码、手机号等信息的页面，实例化一个 AVUser 对象，保存上述补充数据，再次调用 `loginWithauthData` 接口进行登录，并**不再传入 `failOnNotExist` 参数**。示例代码如下：

{% block login_with_authdata_without_fail %}{% endblock %}

#### 接入 UnionID 体系

随着第三方平台的账户体系变得日渐复杂，它们的 authData 出现了一些较大的变化。下面我们以最典型的微信开放平台为例来进行说明。

当一个用户在移动应用内登录微信账号时，会被分配一个 OpenID；在微信小程序内登录账号时，又会被分配另一个不同的 OpenID。这样的架构会导致的问题是，使用同一个微信号的用户，也无法在微信开发平台下的移动应用和小程序之间互通。

微信官方为了解决这个问题，引入 UnionID 的体系，即：**同一微信号，对同一个微信开放平台账号下的不同应用，不管是移动 App、网站应用还是小程序，UnionID 都是相同的**。也就是说，UnionID 可以作为用户的唯一标识。

其他平台，如 QQ 的 UnionID 体系，和微信的设计保持一致。

LeanCloud 支持 UnionID 体系。你只需要给 `loginWithauthData` 和 `associateWithauthData` 接口传入更多的参数，即可完成新 UnionID 体系的集成。

要使用到的关键参数列表：

参数名 | 类型 | 意义
---- | ----- | ----
`platform` | String | 平台，命名随意，如 `weixinapp`、`wxminiprogram`、`qqapp1` 等。
`unionIdPlatform` | String | UnionID 平台，如 `weixin`、`weibo` 和 `qq` 等。
`unionId` | String | 由 UnionID 平台提供。**需配合 `asMainAccount`、`unionIdPlatform` 一起使用**。
`asMainAccount` | boolean | true 代表将 UnionID 绑定入当前 authData 并作为主账号，之后以该 UnionID 来识别。**需配合 `unionId`、`unionIdPlatform` 一起使用**。

接入新 UnionID 系统时，每次传入的 authData 必须包含成对的平台 `uid 或 openid` 和平台 `unionid`。示例代码如下：

{% block login_with_authdata_unionid %}{% endblock %}

然后让我们来看看生成的 authData 的数据格式：

{% block login_with_authdata_unionid_result %}{% endblock %}

当你想加入该 UnionID 下的一个新平台，比如 **miniprogram1** 时，再次登录后生成的数据为：

{% block login_with_authdata_unionid_result_more %}{% endblock %}

可以看到，最终该 authData 实际包含了来自 `weixin` 这个 `unionId` 体系内的两个不同平台，`weixinapp1` 代表来自移动应用，`miniprogram1` 来自小程序。`_weixin_unionid ` 这个字段的值就是用户在 `weixin` 这个 `unionId` 平台的唯一标识 UnionID 值。

当一个用户以来自 weixinapp 的 OpenID `oTY851axxxgujsEl0f36Huxk` 和 UnionID `ox7NLs06ZGfdxxxxxe0F1po78qE` 一起传入生成新的 AVUser 后，接下来这个用户以来自 miniprogram 不同的 OpenID `ohxoK3ldpsGDGGSaniEEexxx` 和同样的 UnionID `ox7NLs06ZGfdxxxxxe0F1po78qE` 一起传入时，LeanCloud 判定是同样的 UnionID，就直接把来自 `miniprogram` 的新用户数据加入到已有 authData 里了，不会再创建新的用户。

这样一来，LeanCloud 后台通过识别平台性的用户唯一标识 UnionID，让来自同一个 UnionID 体系内的应用程序、小程序等不同平台的用户都绑定到了一个 AVUser 上，实现互通。

### 已有 authData 应用接入 UnionID

先梳理一遍业务，看看是否在过去开发过程集成了移动应用程序、小程序等多个平台的 authData，导致同一个用户的数据已经被分别保存为不同的 AVUser：

如果没有的话，直接按前面 [接入 UnionID 体系](#接入-UnionID-体系) 小节的代码集成即可。

如果有的话，需要确认自身的业务需要，确定要以哪个已有平台的账号为主。比如决定使用某个移动应用上生成的账号，则在该移动应用程序更新版本时，使用 `asMainAccount` 参数。这个移动应用带着 UnionID 登录匹配或创建的账号将作为主账号，之后所有这个 UnionID 的登录都会匹配到这个账号。

**请注意**，在第二种情况下 `_User` 表里会剩下一些用户数据，也就是没有被选为主账号的、其他平台的同一个用户的旧账号数据。这部分数据会继续服务于已经发布的但仍然使用 OpenID 登录的旧版应用。

### Demo

为了便于开发者更快熟悉整个开发流程，我们准备了以下示例项目来展示第一阶段 authData 的获取，同时代码也细致地讲解第二阶段与 LeanCloud 用户体系 AVUser 进行集成的各种操作。请下载运行后查看具体代码实现。

- [LeanCloudSNSDemo-Android](https://github.com/leancloud/LeanCloudSNSDemo-Android)
- [LeanCloudSNSDemo-iOS](https://github.com/leancloud/LeanCloudSNSDemo-iOS) 
- [LeanTodo 微信小程序](https://leancloud.cn/docs/weapp.html)

其中，LeanTodo 微信小程序 demo 演示了小程序环境下特有的 [AV.User.loginWithWeapp] 方法。通过该方法，可以在小程序中方便地实现微信一键登录功能。详见[小程序/小游戏用户登录]。

[AV.User.loginWithWeapp]: https://leancloud.github.io/javascript-sdk/docs/AV.User.html#.loginWithWeapp
[小程序/小游戏用户登录]: weapp.html#用户系统

{% endblock %}
{% endif %}

{% block module_in_app_search %}
## 应用内搜索
应用内搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能。要深入了解其用法和阅读示例代码，请阅读 {{inapp_search_guide_url}}。
{% endblock %}

{% if node != 'qcloud' %}
{% block module_in_app_social %}
## 应用内社交
应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能，请参考 {{status_system_guide_url}}。
{% endblock %}
{% endif %}

{% if node != 'qcloud' %}
{% block text_feedback %}
## 用户反馈
用户反馈是一个非常轻量的模块，可以用最少两行的代码来实现一个支持文字和图片的用户反馈系统，并且能够方便的在我们的移动 App 中查看用户的反馈，请参考  {{feedback_guide_url}}。
{% endblock %}
{% endif %}

{% block js_push_guide %}{% endblock %}

{% block use_js_in_webview %}{% endblock %}

{% block faq %}{% endblock %}

## 相关文档

- {{ tutorial_restaurant }}
[livequery-event-login]: livequery-guide.html#针对用户的特殊事件___login
